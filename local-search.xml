<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>interview/article</title>
    <link href="/2021/05/11/interview/index/"/>
    <url>/2021/05/11/interview/index/</url>
    
    <content type="html"><![CDATA[<h4 id="vue性能优化"><a href="#vue性能优化" class="headerlink" title="vue性能优化"></a>vue性能优化</h4><blockquote><p>源码优化<br>s1、代码模块化<br>2、for循环设置key值（让Vue内部核心代码能更快地找到该条数据，当旧值和新值去对比的时候，可以更快的定位到diff）<br>3、Vue路由设置成懒加载（首屏渲染的时候，能够加快渲染速度）<br>4、更加理解Vue的生命周期（不要造成内部泄漏，使用过后的全局变量在组件销毁后重新置为null）。<br>5、可以使用keep-alive<br>配置优化<br>1、修改vue.config.js中的配置项 （productionSourceMap设置为false）<br>2、使用cdn的方式外部加载一些资源<br>4、按需引入组件 （如element 中不需要的不引入）</p></blockquote><h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><p>v-if 指令用于条件性地渲染一块内容，内容只会在指令的表达式返回 true 值的时候被渲染。v-show 只是简单地切换元素的 CSS property display，不支持 <template> 元素，也不支持 v-else。<br>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好</p><h4 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h4><p>1、作用域不同（var是函数作用域，let是块作用域。）<br>2、let不能在定义之前访问该变量，但是var可以。<br>3、let不允许在相同作用域内，重复声明同一个变量。但是var是可以的</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>typescript初入门</title>
    <link href="/2020/10/27/typescript/article1/"/>
    <url>/2020/10/27/typescript/article1/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是TypeScript"><a href="#什么是TypeScript" class="headerlink" title="什么是TypeScript"></a>什么是TypeScript</h3><p>TypeScript 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong></p><p><a href="https://www.typescriptlang.org/">官网</a>的定义：</p><blockquote><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p></blockquote><p>翻译成中文即是：</p><blockquote><p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p></blockquote><h3 id="TypeScript的优势"><a href="#TypeScript的优势" class="headerlink" title="TypeScript的优势"></a>TypeScript的优势</h3><ul><li>TypeScript 增加了代码的可读性和可维护性</li><li>TypeScript 非常包容</li><li>TypeScript 拥有活跃的社区</li></ul><h3 id="TypeScript的劣势"><a href="#TypeScript的劣势" class="headerlink" title="TypeScript的劣势"></a>TypeScript的劣势</h3><ul><li>有一定的学习成本，短期可能会增加一些开发成本</li><li>集成到构建流程需要一些工作量</li><li>可能和一些库结合的不是很完美</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol</p></blockquote><h4 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h4><h5 id="1、布尔值"><a href="#1、布尔值" class="headerlink" title="1、布尔值"></a>1、布尔值</h5><p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> isDone: boolean = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 编译通过</span></code></pre><p>使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> createdByNewBoolean: boolean = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.</span><span class="hljs-comment">//   &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible.</span></code></pre><p>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> createdByNewBoolean: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>);</code></pre><p>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> createdByBoolean: boolean = <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>);</code></pre><p>在 TypeScript 中，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样。</p><h5 id="2、数值"><a href="#2、数值" class="headerlink" title="2、数值"></a>2、数值</h5><p>使用 <code>number</code> 定义数值类型：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> decLiteral: number = <span class="hljs-number">6</span>;<span class="hljs-keyword">let</span> hexLiteral: number = <span class="hljs-number">0xf00d</span>;<span class="hljs-comment">// ES6 中的二进制表示法</span><span class="hljs-keyword">let</span> binaryLiteral: number = <span class="hljs-number">0b1010</span>;<span class="hljs-comment">// ES6 中的八进制表示法</span><span class="hljs-keyword">let</span> octalLiteral: number = <span class="hljs-number">0o744</span>;<span class="hljs-keyword">let</span> notANumber: number = <span class="hljs-literal">NaN</span>;<span class="hljs-keyword">let</span> infinityNumber: number = <span class="hljs-literal">Infinity</span>;</code></pre><p>编译结果</p><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> decLiteral = <span class="hljs-number">6</span>;<span class="hljs-keyword">var</span> hexLiteral = <span class="hljs-number">0xf00d</span>;<span class="hljs-comment">// ES6 中的二进制表示法</span><span class="hljs-keyword">var</span> binaryLiteral = <span class="hljs-number">10</span>;<span class="hljs-comment">// ES6 中的八进制表示法</span><span class="hljs-keyword">var</span> octalLiteral = <span class="hljs-number">484</span>;<span class="hljs-keyword">var</span> notANumber = <span class="hljs-literal">NaN</span>;<span class="hljs-keyword">var</span> infinityNumber = <span class="hljs-literal">Infinity</span>;</code></pre><h5 id="3、字符串"><a href="#3、字符串" class="headerlink" title="3、字符串"></a>3、字符串</h5><p>使用 <code>string</code> 定义字符串类型：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> myName: string = <span class="hljs-string">&#x27;Tom&#x27;</span>;<span class="hljs-keyword">let</span> myAge: number = <span class="hljs-number">25</span>;<span class="hljs-comment">// 模板字符串</span><span class="hljs-keyword">let</span> sentence: string = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;myName&#125;</span>.</span><span class="hljs-string">I&#x27;ll be <span class="hljs-subst">$&#123;myAge + <span class="hljs-number">1</span>&#125;</span> years old next month.`</span>;</code></pre><p>编译结果</p><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;Tom&#x27;</span>;<span class="hljs-keyword">var</span> myAge = <span class="hljs-number">25</span>;<span class="hljs-comment">// 模板字符串</span><span class="hljs-keyword">var</span> sentence = <span class="hljs-string">&quot;Hello, my name is &quot;</span> + myName + <span class="hljs-string">&quot;.\nI&#x27;ll be &quot;</span> + (myAge + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; years old next month.&quot;</span>;</code></pre><h5 id="4、空值"><a href="#4、空值" class="headerlink" title="4、空值"></a>4、空值</h5><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertName</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;    alert(<span class="hljs-string">&#x27;My name is Tom&#x27;</span>);&#125;</code></pre><p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> unusable: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;</code></pre><h5 id="5、Null-和-Undefined"><a href="#5、Null-和-Undefined" class="headerlink" title="5、Null 和 Undefined"></a>5、Null 和 Undefined</h5><p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</code></pre><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p><pre><code class="hljs Javascript"><span class="hljs-comment">// 这样不会报错</span><span class="hljs-keyword">let</span> num: number = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 这样也不会报错</span><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span>;<span class="hljs-keyword">let</span> num: number = u</code></pre><h4 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h4><blockquote><p>任意值（Any）用来表示允许赋值为任意类型。</p></blockquote><p>一个普通类型，在赋值过程中改变类型是不被允许的：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> myFavoriteNumber: string = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;<span class="hljs-comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></code></pre><p>如果是 any 类型，则允许被赋值为任意类型。</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> myFavoriteNumber: any = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;</code></pre><p>任意值的属性和方法</p><pre><code class="hljs Javascript"><span class="hljs-comment">// 在任意值上访问任何属性都是允许的</span><span class="hljs-keyword">let</span> anyThing: any = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-built_in">console</span>.log(anyThing.myName);<span class="hljs-built_in">console</span>.log(anyThing.myName.firstName);<span class="hljs-comment">//也允许调用任何方法</span><span class="hljs-keyword">let</span> anyThing: any = <span class="hljs-string">&#x27;Tom&#x27;</span>;anyThing.setName(<span class="hljs-string">&#x27;Jerry&#x27;</span>);anyThing.setName(<span class="hljs-string">&#x27;Jerry&#x27;</span>).sayHello();anyThing.myName.setFirstName(<span class="hljs-string">&#x27;Cat&#x27;</span>);</code></pre><p><strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong></p><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><blockquote><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p></blockquote><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。以下代码虽然没有指定类型，但是会在编译的时候报错：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;<span class="hljs-comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span>等价于<span class="hljs-keyword">let</span> myFavoriteNumber: string = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;<span class="hljs-comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></code></pre><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</strong></p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> myFavoriteNumber;myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;</code></pre><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><blockquote><p>合类型（Union Types）表示取值可以为多种类型中的一种。使用 | 分隔每个类型。</p></blockquote><pre><code class="hljs Javascript"><span class="hljs-comment">// 允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。</span><span class="hljs-keyword">let</span> myFavoriteNumber: string | number;myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;myFavoriteNumber = <span class="hljs-literal">true</span>; <span class="hljs-comment">//不被允许</span><span class="hljs-comment">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span><span class="hljs-comment">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span></code></pre><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong></p><pre><code class="hljs Javascript"><span class="hljs-comment">// length 不是 string 和 number 的共有属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">something: string | number</span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> something.length;&#125;<span class="hljs-comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><span class="hljs-comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;</span><span class="hljs-comment">//访问 string 和 number 的共有属性是没问题的</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">something: string | number</span>): <span class="hljs-title">string</span> </span>&#123;    <span class="hljs-keyword">return</span> something.toString();&#125;</code></pre><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> myFavoriteNumber: string | number;myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>; <span class="hljs-comment">// myFavoriteNumber 被推断成了 string, 访问它的 length 属性不会报错</span><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 5</span>myFavoriteNumber = <span class="hljs-number">7</span>; <span class="hljs-comment">// myFavoriteNumber 被推断成了 number, 访问它的 length 属性会报错</span><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 编译时报错</span><span class="hljs-comment">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></code></pre><h4 id="对象的类型–接口"><a href="#对象的类型–接口" class="headerlink" title="对象的类型–接口"></a>对象的类型–接口</h4><h5 id="1、什么是接口"><a href="#1、什么是接口" class="headerlink" title="1、什么是接口"></a>1、什么是接口</h5><blockquote><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p></blockquote><blockquote><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p></blockquote><blockquote><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p></blockquote><p>定义一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。</p><pre><code class="hljs Javascript">interface Person &#123;    name: string;    age: number;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    age: <span class="hljs-number">25</span>&#125;;<span class="hljs-comment">// 定义的变量比接口少了一些属性是不允许的：</span>interface Person &#123;    name: string;    age: number;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;;<span class="hljs-comment">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><span class="hljs-comment">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span><span class="hljs-comment">//多一些属性也是不允许的：</span>nterface Person &#123;    name: string;    age: number;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    age: <span class="hljs-number">25</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;<span class="hljs-comment">// error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><span class="hljs-comment">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span></code></pre><p><strong>赋值的时候，变量的形状必须和接口的形状保持一致。</strong> </p><h5 id="2、可选属性"><a href="#2、可选属性" class="headerlink" title="2、可选属性"></a>2、可选属性</h5><p>有时我们希望不要完全匹配一个形状（即：可选属性的含义是该属性可以不存在），那么可以用可选属性：</p><pre><code class="hljs Javascript">interface Person &#123;    name: string;    age?: number;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;;</code></pre><p>注意：<strong>仍然不允许添加未定义的属性：</strong></p><pre><code class="hljs Javascript">interface Person &#123;    name: string;    age?: number;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    age: <span class="hljs-number">25</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;<span class="hljs-comment">// error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span>  <span class="hljs-built_in">Object</span> literal may only specify known properties, and <span class="hljs-string">&#x27;gender&#x27;</span> does not exist <span class="hljs-keyword">in</span> type <span class="hljs-string">&#x27;Person&#x27;</span>.</code></pre><h5 id="3、任意属性"><a href="#3、任意属性" class="headerlink" title="3、任意属性"></a>3、任意属性</h5><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p><pre><code class="hljs Javascript">interface Person &#123;    name: string;    age?: number;    [propName: string]: any;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;</code></pre><p>使用 <code>[propName: string]</code> 定义了任意属性取 string 类型的值。<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>：</p><pre><code class="hljs Javascript">interface Person &#123;    name: string;    age?: number;    [propName: string]: string;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    age: <span class="hljs-number">25</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;<span class="hljs-comment">//error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span>  Property <span class="hljs-string">&#x27;age&#x27;</span> is incompatible <span class="hljs-keyword">with</span> index signature.    Type <span class="hljs-string">&#x27;number&#x27;</span> is not assignable to type <span class="hljs-string">&#x27;string&#x27;</span>.</code></pre><p>上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</p><p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p><pre><code class="hljs Javascript">interface Person &#123;    name: string;    age?: number;    [propName: string]: string | number;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    age: <span class="hljs-number">25</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;</code></pre><h5 id="4、只读属性"><a href="#4、只读属性" class="headerlink" title="4、只读属性"></a>4、只读属性</h5><p>有些字段只能在创建的时候被赋值，可以用 readonly 定义只读属性:</p><pre><code class="hljs Javascript">interface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    id: <span class="hljs-number">0</span>,    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;tom.id = <span class="hljs-number">1</span>;<span class="hljs-comment">// error TS2540: Cannot assign to &#x27;id&#x27; because it is a read-only property.</span></code></pre><p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</strong></p><pre><code class="hljs Javascript">interface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;tom.id = <span class="hljs-number">1</span>;<span class="hljs-comment">// error TS2741: Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27; but required in type &#x27;Person&#x27;.</span><span class="hljs-comment">//Cannot assign to &#x27;id&#x27; because it is a read-only property</span><span class="hljs-comment">//上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。</span><span class="hljs-comment">//第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。</span></code></pre><h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><h5 id="1、类型-方括号」表示法"><a href="#1、类型-方括号」表示法" class="headerlink" title="1、类型 + 方括号」表示法"></a>1、类型 + 方括号」表示法</h5><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> a: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<span class="hljs-comment">//数组项中不允许出现其他类型</span><span class="hljs-keyword">let</span> a: number[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<span class="hljs-comment">// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></code></pre><p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制，push 方法只允许传入 number 类型的参数:</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> a: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];a.push(<span class="hljs-string">&#x27;8&#x27;</span>);<span class="hljs-comment">// Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;</span></code></pre><h5 id="2、数组泛型"><a href="#2、数组泛型" class="headerlink" title="2、数组泛型"></a>2、数组泛型</h5><p>数组泛型（Array Generic） <code>Array &lt;elemType&gt;</code> 来表示数组</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">Array</span>&lt;number&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];</code></pre><h5 id="3、用接口表示数组"><a href="#3、用接口表示数组" class="headerlink" title="3、用接口表示数组"></a>3、用接口表示数组</h5><pre><code class="hljs Javascript">interface NumberArray &#123;    [index: number]: number;&#125;<span class="hljs-keyword">let</span> a: NumberArray = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];</code></pre><p>NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p><h5 id="4、类数组"><a href="#4、类数组" class="headerlink" title="4、类数组"></a>4、类数组</h5><p>类数组（Array-like Object）不是数组类型，比如 arguments：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> args: number[] = <span class="hljs-built_in">arguments</span>;&#125;<span class="hljs-comment">// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span></code></pre><p>上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> args: &#123;        [index: number]: number;        length: number;        callee: <span class="hljs-built_in">Function</span>;    &#125; = <span class="hljs-built_in">arguments</span>;&#125;</code></pre><h5 id="5、any-在数组中的应用"><a href="#5、any-在数组中的应用" class="headerlink" title="5、any 在数组中的应用"></a>5、any 在数组中的应用</h5><p>any 表示数组中允许出现任意类型：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> list: any[] = [<span class="hljs-string">&#x27;xcatliu&#x27;</span>, <span class="hljs-number">25</span>, &#123; <span class="hljs-attr">website</span>: <span class="hljs-string">&#x27;http://xcatliu.com&#x27;</span> &#125;];</code></pre><h4 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h4><h5 id="1、函数声明"><a href="#1、函数声明" class="headerlink" title="1、函数声明"></a>1、函数声明</h5><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p><pre><code class="hljs Javascript"><span class="hljs-comment">// 函数声明（Function Declaration）</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-comment">// 函数表达式（Function Expression）</span><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;;</code></pre><p>在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;</code></pre><p><strong>注意，输入多余的（或者少于要求的）参数，是不被允许的：</strong></p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">// Expected 2 arguments, but got 3.</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;sum(<span class="hljs-number">1</span>);<span class="hljs-comment">//  Expected 2 arguments, but got 1.</span></code></pre><h5 id="2、函数表达式"><a href="#2、函数表达式" class="headerlink" title="2、函数表达式"></a>2、函数表达式</h5><p>写一个对函数表达式（Function Expression）的定义</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;;</code></pre><p>上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：</p><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> mySum: <span class="hljs-function">(<span class="hljs-params">x: number, y: number</span>) =&gt;</span> number = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;;</code></pre><p><strong>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</strong></p><h5 id="3、用接口定义函数的形状"><a href="#3、用接口定义函数的形状" class="headerlink" title="3、用接口定义函数的形状"></a>3、用接口定义函数的形状</h5><pre><code class="hljs Javascript">interface SearchFunc &#123;    (source: string, <span class="hljs-attr">subString</span>: string): boolean;&#125;<span class="hljs-keyword">let</span> mySearch: SearchFunc;mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: string, subString: string</span>) </span>&#123;    <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;&#125;</code></pre><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><h5 id="4、可选参数"><a href="#4、可选参数" class="headerlink" title="4、可选参数"></a>4、可选参数</h5><p>用 ? 表示可选的参数:</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: string, lastName?: string</span>) </span>&#123;    <span class="hljs-keyword">if</span> (lastName) &#123;        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> firstName;    &#125;&#125;<span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>);</code></pre><p><strong>注意：可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数：</strong></p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName?: string, lastName: string</span>) </span>&#123;    <span class="hljs-keyword">if</span> (firstName) &#123;        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> lastName;    &#125;&#125;<span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>);<span class="hljs-comment">// A required parameter cannot follow an optional parameter</span></code></pre><h5 id="5、参数默认值"><a href="#5、参数默认值" class="headerlink" title="5、参数默认值"></a>5、参数默认值</h5><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数：</strong></p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: string, lastName: string = <span class="hljs-string">&#x27;Cat&#x27;</span></span>) </span>&#123;    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;&#125;<span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>);</code></pre><p>此时不受「可选参数必须接在必需参数后面」的限制：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: string = <span class="hljs-string">&#x27;Tom&#x27;</span>, lastName: string</span>) </span>&#123;    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;&#125;<span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<span class="hljs-keyword">let</span> cat = buildName(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);</code></pre><h5 id="6、剩余参数"><a href="#6、剩余参数" class="headerlink" title="6、剩余参数"></a>6、剩余参数</h5><p>ES6 中，可以使用 …rest 的方式获取函数中的剩余参数（rest 参数）：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array, ...items</span>) </span>&#123;    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;        array.push(item);    &#125;);&#125;<span class="hljs-keyword">let</span> a: any[] = [];push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array: any[], ...items: any[]</span>) </span>&#123;    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;        array.push(item);    &#125;);&#125;<span class="hljs-keyword">let</span> a = [];push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre><p>注意：<strong>rest 参数只能是最后一个参数</strong></p><h5 id="7、重载"><a href="#7、重载" class="headerlink" title="7、重载"></a>7、重载</h5><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: number | string</span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);    &#125;&#125;</code></pre><p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong><br>可以使用重载定义多个 reverse 的函数类型：</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: number</span>): <span class="hljs-title">number</span></span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: string</span>): <span class="hljs-title">string</span></span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: number | string</span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);    &#125;&#125;</code></pre><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><h5 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h5><pre><code class="hljs actionscript">值 <span class="hljs-keyword">as</span> 类型 或 &lt;类型&gt;值</code></pre><h5 id="2、用途"><a href="#2、用途" class="headerlink" title="2、用途"></a>2、用途</h5><blockquote><ul><li>将一个联合类型断言为其中一个类型</li><li>将一个父类断言为更加具体的子类</li><li>将任何一个类型断言为 any</li><li>将 any 断言为一个具体的类型</li></ul></blockquote><p>文章参考来自<a href="https://ts.xcatliu.com/">阮一峰</a>老师</p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些项目中用到的方法（正则、去重、时间转换and more)</title>
    <link href="/2018/12/06/other/someMethod/"/>
    <url>/2018/12/06/other/someMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>1、验证IP</p><pre><code class="hljs JavaScript">/^(\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;|<span class="hljs-number">1</span>\d\d|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d|<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])(\.(\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;|<span class="hljs-number">1</span>\d\d|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d|<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]))&#123;<span class="hljs-number">3</span>&#125;$/</code></pre><p>2、验证邮箱</p><pre><code class="hljs JavaScript">/^(([^<span class="xml"><span class="hljs-tag">&lt;&gt;</span>()[\]\\.,;:\s@&quot;]+(\.[^<span class="hljs-tag">&lt;&gt;</span>()[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/</span></code></pre><a id="more"></a><p>3、验证端口</p><pre><code class="hljs JavaScript">/^([<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>&#125;)$/</code></pre><p>4、验证http开头的IP</p><pre><code class="hljs JavaScript">/^(http|https):\/\/(((\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;|<span class="hljs-number">1</span>\d\d|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d|<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])(\.(\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;|<span class="hljs-number">1</span>\d\d|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d|<span class="hljs-number">25</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]))&#123;<span class="hljs-number">3</span>&#125;)|([a-z0-<span class="hljs-number">9</span>]+(\.&#123;<span class="hljs-number">1</span>&#125;[a-z0-<span class="hljs-number">9</span>]+)*(\.[a-z]+)&#123;<span class="hljs-number">1</span>&#125;))(:([<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;|[<span class="hljs-number">1</span>-<span class="hljs-number">5</span>]\d&#123;<span class="hljs-number">4</span>&#125;|<span class="hljs-number">6</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]&#123;<span class="hljs-number">2</span>&#125;[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>][<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]))&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;$/</code></pre><p>5、验证输入值为字母数字下划线，且以字母开头</p><pre><code class="hljs JavaScript">/^([a-zA-Z]+[A-Za-z0-<span class="hljs-number">9</span>_]*[a-zA-Z0-<span class="hljs-number">9</span>_]*)$/</code></pre><p>6、检查是否包含中文</p><pre><code class="hljs JavaScript">/[\u4E00-\u9FA5\uF900-\uFA2D]/</code></pre><h2 id="对象数组转换"><a href="#对象数组转换" class="headerlink" title="对象数组转换"></a>对象数组转换</h2><p>1、数组去重</p><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>][...new <span class="hljs-built_in">Set</span>(arr)] =&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</code></pre><p>2、获取数组的重复元素</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRepeatItems</span>(<span class="hljs-params">array</span>) </span>&#123;  <span class="hljs-keyword">const</span> repeatItem = [],    map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  array.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(item) &amp;&amp; !repeatItem.includes(item)) &#123;      repeatItem.push(item)    &#125;    <span class="hljs-keyword">if</span> (!map.has(item)) &#123;      map.set(item, item)    &#125;  &#125;)  <span class="hljs-keyword">return</span> map&#125;getRepeatItems([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) =&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</code></pre><p>3、去掉object中值为空的key</p><pre><code class="hljs Javascript"><span class="hljs-comment">//注 isNil omit为lodash中的方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">omitNilKey</span>(<span class="hljs-params">obj</span>)</span>&#123;  <span class="hljs-keyword">const</span> omitKeyArray = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;    <span class="hljs-keyword">if</span> (isNil(obj[key]) || obj[key] === <span class="hljs-string">&#x27;&#x27;</span>) &#123;      omitKeyArray.push(key)    &#125;  &#125;  <span class="hljs-keyword">return</span> omit(obj, omitKeyArray)&#125;omitNilKey(&#123;<span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;xxxxxx&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> &#125;) =&gt; &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&quot;xxxxxx&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>&#125;</code></pre><p>3、将秒语义化</p><pre><code class="hljs Javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertSecondsToTotalTime</span>(<span class="hljs-params">seconds</span>) </span>&#123;  <span class="hljs-keyword">if</span> (seconds &gt; <span class="hljs-number">0</span> &amp;&amp; seconds &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;seconds.toFixed(<span class="hljs-number">2</span>)&#125;</span>秒`</span>    &#125;    <span class="hljs-keyword">if</span> (seconds === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;暂无数据&#x27;</span>    &#125;    <span class="hljs-keyword">let</span> second = <span class="hljs-built_in">parseInt</span>(seconds, <span class="hljs-number">10</span>)    <span class="hljs-keyword">let</span> minute = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> hour = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">if</span> (second &gt; <span class="hljs-number">60</span>) &#123;      minute = <span class="hljs-built_in">parseInt</span>(second / <span class="hljs-number">60</span>, <span class="hljs-number">10</span>)      second = <span class="hljs-built_in">parseInt</span>(second % <span class="hljs-number">60</span>, <span class="hljs-number">10</span>)      <span class="hljs-keyword">if</span> (minute &gt; <span class="hljs-number">60</span>) &#123;        hour = <span class="hljs-built_in">parseInt</span>(minute / <span class="hljs-number">60</span>, <span class="hljs-number">10</span>)        minute = <span class="hljs-built_in">parseInt</span>(minute % <span class="hljs-number">60</span>, <span class="hljs-number">10</span>)      &#125;    &#125;    result += hour &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;hour&#125;</span>小时`</span> : <span class="hljs-string">&#x27;&#x27;</span>    result += minute &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;minute&#125;</span>分`</span> : <span class="hljs-string">&#x27;&#x27;</span>    result += second &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;second&#125;</span>秒`</span> : <span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">return</span> result  &#125;  convertSecondsToTotalTime(<span class="hljs-number">6000</span>) =&gt; <span class="hljs-number">1</span>小时<span class="hljs-number">40</span>分&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异步流程控制</title>
    <link href="/2017/08/01/async/"/>
    <url>/2017/08/01/async/</url>
    
    <content type="html"><![CDATA[<p>1什么是异步？<br>就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段（异步函数书写的时候不用”return”来返回值，必须通过回调函数来返回值）</p><pre><code class="hljs JavaScript"><span class="hljs-comment">//例1</span><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">var</span> data = fs.readFileSync(<span class="hljs-string">&#x27;text.txt&#x27;</span>)<span class="hljs-built_in">console</span>.log(data.toString());<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;程序执行结束!&quot;</span>);<span class="hljs-comment">//执行结果：text, 程序执行结束</span><span class="hljs-comment">//例2</span>fs.readFile(<span class="hljs-string">&#x27;text.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(err);  <span class="hljs-built_in">console</span>.log(data.toString());&#125;);<span class="hljs-comment">//执行结果：程序执行结束， text</span></code></pre><p>以上代码可以看出例1是个同步函数，如果读取的text文件过大，会阻塞下面程序的执行，而例2会先读文件在执行其他程序，最后打印text的内容</p><a id="more"></a><h2 id="1、callback"><a href="#1、callback" class="headerlink" title="1、callback"></a>1、callback</h2><p>是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，这就是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。<br>以读取文件为例：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span> (<span class="hljs-params">file, callback</span>) </span>&#123;    fs.readFile(file, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-built_in">console</span>.log(err)      &#125; <span class="hljs-keyword">else</span> &#123;        callback(data.toString())      &#125;    &#125;);&#125;fun(<span class="hljs-string">&#x27;text.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data1</span>)</span>&#123;  fun(<span class="hljs-string">&#x27;text1.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data2</span>) </span>&#123;    <span class="hljs-comment">//dosomething</span>  &#125;)&#125;)</code></pre><p>从上面读取文件的例子可以看出callback函数最大多的问题在于陷入回调地狱，一层套一层的代码，可读性和维护性差</p><h2 id="2、Stream"><a href="#2、Stream" class="headerlink" title="2、Stream"></a>2、Stream</h2><p>Stream（流）是很多I/0操作的抽象，被 Node 中的很多对象所实现。比如一个 HTTP 服务器的请求是一个流（可读流）（服务器的响应是一个流（可写流））。流是可读、可写或兼具两者的。所有流都是 EventEmitter 的实例。<br>stream有四种类型：<br>Readable，可读流<br>Writable，可写流<br>Duplex，读写流 (例：<a href="http://codewinds.com/blog/2013-08-31-nodejs-duplex-streams.html">http://codewinds.com/blog/2013-08-31-nodejs-duplex-streams.html</a>)<br>Transform，扩展的Duplex<br>以读取文件为例，传统方式是用fs.readFile，这种方法会将数据全部读入内存，读取效率低。通过stream的createReadStream会将文件数据切割成小块，写入特定的处理函数，会大大提高效率。此文主要讲解Readable和Writable。<br>例:</p><pre><code class="hljs JavaScript"> <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <span class="hljs-keyword">var</span> readabler = fs.createReadStream(src) ; <span class="hljs-comment">//创建可读流</span> <span class="hljs-keyword">var</span> writeabler = fs.createWriteStream(src) <span class="hljs-comment">//创建可写流</span> <span class="hljs-comment">//readtable使用方式</span> readabler.read(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;     rs.pause() ; <span class="hljs-comment">//pause暂停执行</span>     doSomething(chunk, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;         rs.resume() ; <span class="hljs-comment">//恢复读取</span>     &#125;) ; &#125;) ; readabler.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     doSomething(); &#125;)  ;<span class="hljs-comment">//writable使用方式</span>writeabler.write(<span class="hljs-string">&#x27;text1&#x27;</span>, <span class="hljs-string">&#x27;UTF8&#x27;</span>);writeabler.on(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; 给writeabler增加监听事件  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;写入完成。&quot;</span>);&#125;);writeabler.end() <span class="hljs-comment">//注意：end后不可再写入</span></code></pre><p> 下面是一个读取时写入的例子<br> <pre><code class="hljs JavaScript"> <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <span class="hljs-keyword">var</span> readableStream = fs.createReadStream(src) ; <span class="hljs-keyword">var</span> writableStream = fs.createWriteStream(src); readableStream.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>)</span>&#123;    <span class="hljs-keyword">if</span> (writableStream.write(chunk, <span class="hljs-string">&#x27;UTF8&#x27;</span>) === <span class="hljs-literal">null</span>);    readableStream.pause() <span class="hljs-comment">//此步骤的作用是当读取到的文件过大可能还没写完会造成文件丢失，故暂停读取</span>&#125;);writableStream.on(<span class="hljs-string">&#x27;drain&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 监听是否读取的内容是否写完，写完后，继续读取</span>    readableStream.resume();&#125;);readableStream.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 当没有数据时，关闭数据流</span>    writableStream.end();&#125;);</code></pre><br> 上面的例子通过pipe可以轻易实现readableStream.pipe(writableStream)。pipe相当于文件交流的管道，可以控制文件的流向。</p><p> 官网：<a href="http://nodejs.cn/api/stream#stream_stream">http://nodejs.cn/api/stream#stream_stream</a></p><h2 id="3、promise"><a href="#3、promise" class="headerlink" title="3、promise"></a>3、promise</h2><p>Promise 构造函数包含一个参数和一个带有 resolve（解析)和reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected，且状态一旦改变就不会再变</p><p>Promise对象是一个构造函数，用来生成Promise实例</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// do a thing, possibly async, then…</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* everything turned out fine */</span>) &#123;    resolve(<span class="hljs-string">&quot;Stuff worked!&quot;</span>); <span class="hljs-comment">//resolve在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</span>  &#125;  <span class="hljs-keyword">else</span> &#123;    reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;It broke&quot;</span>)); <span class="hljs-comment">//reject在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</span>  &#125;&#125;);</code></pre><p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Rejected状态的回调函数</p><pre><code class="hljs JavaScript">promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// &quot;Stuff worked!&quot;</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(err); <span class="hljs-comment">// Error: &quot;It broke&quot;</span>&#125;);</code></pre><p>then() 方法接受两个回调函数作为参数：一个用于成功情形的回调和一个用于失败情形的回调。这两个都是可选的，因此您可以只添加一个用于成功情形或失败情形的回调。</p><p>Promise 新建后就会立即执行</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;start&#x27;</span>)    resolve()&#125;)promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end&#x27;</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>)<span class="hljs-comment">// &#x27;start&#x27; =&gt; &#x27;hi&#x27; =&gt; &#x27;end&#x27;</span></code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完才会执行，所以Resolved最后输出。</p><p>调用resolve或reject并不会终结 Promise 的参数函数的执行。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  resolve(<span class="hljs-number">1</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;).then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(r);&#125;);<span class="hljs-comment">// 2</span><span class="hljs-comment">// 1</span></code></pre><p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。<br>Promise.prototype.then()<br>作用是为Promise实例添加状态改变时的回调函数。</p><pre><code class="hljs JavaScript"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sucess, fail</span>) </span>&#123;    <span class="hljs-built_in">this</span>.done(sucess);    <span class="hljs-built_in">this</span>.fail(fail);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;;</code></pre><p>Promise.prototype.catch()用于指定发生错误时的回调函数。如果Promise状态已经变成Resolved，在抛错是无效的<br>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外<br>Promise.all()用于将多个 Promise 实例，包装成一个新的 Promise 实例。。<br>,Promise.resolve(),Promise.reject()都是将非promise的对象转化为promise对象，其不同点在于生成对象实例的状态不同。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);<span class="hljs-keyword">var</span> q = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello&#x27;</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-string">&#x27;出错了&#x27;</span>))<span class="hljs-keyword">var</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-string">&#x27;hello&#x27;</span>))p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(v)  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(s)&#125;);</code></pre><p>bluebird对promise的封装：<a href="http://bluebirdjs.com/docs/api-reference.html">http://bluebirdjs.com/docs/api-reference.html</a></p><h2 id="4、Generator"><a href="#4、Generator" class="headerlink" title="4、Generator"></a>4、Generator</h2><p>参照网址：<a href="http://es6.ruanyifeng.com/#docs/generator">http://es6.ruanyifeng.com/#docs/generator</a><br>Generator函数形式上是一个普通函数，有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。执行 Generator函数会返回一个遍历器对象(value: value; done: false/true）value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;first msg&#x27;</span>&#125;<span class="hljs-keyword">var</span> a = gen() <span class="hljs-comment">//获取遍历器对象</span>a.next() <span class="hljs-comment">//执行函数并返回&#123;value: &#x27;first msg&#x27;, done: false&#125;</span>a.next  <span class="hljs-comment">//执行函数并返回&#123;value: undefined, done: true&#125;</span></code></pre><p>注意，generator函数也可以不用yield表达式，此时该函数就是一个单纯的暂缓执行函数,yield表达式只能在generator函数中使用</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;first msg&#x27;</span>)&#125;<span class="hljs-keyword">var</span> a = gen()a.next() <span class="hljs-comment">//first msg; &#123;value: undefined, done: true&#125;</span></code></pre><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;start&#x27;</span>)    <span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;first msg&#x27;</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am back and bring&#x27;</span> + msg)&#125;<span class="hljs-keyword">var</span> a = gen()a.next() <span class="hljs-comment">// start; &#123;value: &#x27;first msg&#x27;, done: false&#125;</span>a.next(<span class="hljs-string">&#x27;something from outside&#x27;</span>) <span class="hljs-comment">// &#123;value: &#x27;I am back and bring something from outside&#x27;, done: false&#125;</span>a.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span></code></pre><p>例</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span> * (yeild(x + <span class="hljs-number">1</span>))    <span class="hljs-keyword">var</span> z = yeild(y * <span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> (x +y + z)&#125;<span class="hljs-keyword">var</span> a = gen(<span class="hljs-number">2</span>) <span class="hljs-comment">// x: 2; y: undefined; z: undefind</span>a.next() &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;a.next() &#123;<span class="hljs-attr">value</span>: NAN, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;a.next() &#123;<span class="hljs-attr">value</span>: NAN, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;a.next(<span class="hljs-number">3</span>) &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125; <span class="hljs-comment">//yeild(x + 1)被赋值为3， y=6;</span>a.next(<span class="hljs-number">4</span>) &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125; <span class="hljs-comment">//yeild(y * 2)被赋值为4, z=4;</span></code></pre><p>Generator函数可以用return 方法给定返回的值，终结函数</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;&#125;<span class="hljs-keyword">var</span> a = gen();a.next()        <span class="hljs-comment">// &#123; value: 1, done: false &#125;</span>a.return(<span class="hljs-string">&#x27;first msg&#x27;</span>)    <span class="hljs-comment">//&#123; value: &#x27;first msg&#x27;, done: true &#125;</span>注意：<span class="hljs-keyword">return</span>中如果没有参数，则返回的value为<span class="hljs-literal">undefined</span>。如果 Generator 函数内部有<span class="hljs-keyword">try</span>...finally代码块，那么<span class="hljs-keyword">return</span>方法会推迟到<span class="hljs-keyword">finally</span>代码块执行完再执行<span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;  &#125;  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;&#125;<span class="hljs-keyword">var</span> a = gen();a.next() <span class="hljs-comment">// &#123; value: 1, done: false &#125;</span>a.next() <span class="hljs-comment">// &#123; value: 2, done: false &#125;</span>a.return(<span class="hljs-number">5</span>) <span class="hljs-comment">// &#123; value: 3, done: false &#125;</span>a.next() <span class="hljs-comment">// &#123; value: 5, done: true &#125;</span></code></pre><p>如果在 Generator 函数内部，调用另一个Generator函数，默认情况下是没有效果的。需要加上yield*</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;x&#x27;</span>;  foo();  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;y&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">yield</span>* foo();  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> bar())&#123;  <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// &#x27;x&#x27;, &#x27;y&#x27;</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> gen())&#123;  <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 1, &#x27;a&#x27;, &#x27;b&#x27; 2</span>&#125;</code></pre><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params">x</span>)</span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">2</span>;  &#125; <span class="hljs-keyword">catch</span> (e)&#123;    <span class="hljs-built_in">console</span>.log(e);  &#125;  <span class="hljs-keyword">return</span> y;&#125;<span class="hljs-keyword">var</span> g = gen(<span class="hljs-number">1</span>);g.next();g.throw（<span class="hljs-string">&#x27;出错了&#x27;</span>）</code></pre><p>Thunk函数用于generator函数的流程管理，让其自动执行generator函数<br>co函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。<br>github地址：<a href="https://github.com/tj/co">https://github.com/tj/co</a></p><h2 id="5、async-function"><a href="#5、async-function" class="headerlink" title="5、async function"></a>5、async function</h2><p>异步函数会返回一个promise对象。调用成功时会用promise的resolve方法来处理这个返回值，抛出异常或者非法值时，会使用promise的reject方法来处理这个异常值。<br>类似generator</p><pre><div class="caption"><span>JavaScript</span></div><code class="hljs bash">async <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span> () &#123;    var a = await <span class="hljs-string">&#x27;123&#x27;</span>    var b = await <span class="hljs-string">&#x27;234&#x27;</span>    console.log(a, b)&#125;foo () // 123, 234</code></pre><p>async流程工具包：<a href="http://caolan.github.io/async/">http://caolan.github.io/async/</a></p><h2 id="6、RxJS"><a href="#6、RxJS" class="headerlink" title="6、RxJS"></a>6、RxJS</h2><p>rxjs全名Reactive Extensions for JavaScript，Javascript的响应式扩展，响应式的思路是把随时间不断变化的数据、状态、事件等等转成可被观察的序列(Observable Sequence)，然后订阅序列中那些Observable对象的变化，一旦变化，就会执行事先安排好的各种转换和操作<br>rxjs核心:</p><ul><li>Observable: 可观察的数据对象</li><li>Observer: 观察者实例，用来决定何时观察指定数据.</li><li>Subscription: 观察数据序列返回订阅实例.</li><li>Operators: Observable的操作方法，包括转换数据序列，过滤等，所有的Operators方法接受的参数是上一次发送的数据变更的值，而方法返回值我们称之为发射新数据变更.</li><li>Subject: 计时观察者也是观察者对象.</li><li>Schedulers: 控制调度并发，即当Observable接受Subject的变更响应时，可以通过scheduler设置响应方式，目前内置的响应可以调用Object.keys(Rx.Subject)查看</li></ul><p><font color=#c7254e size=3>Observable</font><br>例：</p><pre><code class="hljs JavaScript"><span class="hljs-comment">//可观察对象可以使用create创建，也可以用of,from,interval等</span><span class="hljs-keyword">var</span> observable = Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribe</span>(<span class="hljs-params">observer</span>) </span>&#123;  observer.next(<span class="hljs-number">1</span>)  &#125;)<span class="hljs-comment">//Operators</span>  observable.map(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item * <span class="hljs-number">10</span>)<span class="hljs-comment">//观察者</span>  <span class="hljs-keyword">var</span> observe = &#123;    next: <span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-built_in">console</span>.log(x),    error: <span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span><span class="hljs-built_in">console</span>.log(err),    complete: <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;done&#x27;</span>),  &#125;<span class="hljs-comment">//观察者订阅可观察者对象</span>  observable.subscribe(observe)<span class="hljs-comment">//output: 1</span></code></pre><p>上面代码中使用Rx.Observable.create操作符来创造一个可观察对象，使用一个观察者订阅它，可观察对象执行后给观察者发送next/error/complete通知。由于使用了map创建了一个新的可观察对象，新的可观察对象与当前可观察对象没有关系，故值为1。</p><blockquote><p>在Observable.create(function(observer){…})中的代码，表示了一个可观察对象的执行，一个仅在观察者订阅的时候发生的惰性计算。执行随着时间产生多个值，以同步或者异步的方式。<br>下面是可观察对象执行可以发送的三种类型的值:</p></blockquote><ul><li>“Next”: 发送一个数字/字符串/对象等值。</li><li>“Error”: 发送一个JS错误或者异常。</li><li>“Complete” 不发送值。<br>Next通知是最重要且最常见的类型:它们代表发送给观察者的确切数据，Error和Complete通知可能仅在可观察对象执行期间仅发生一次，但仅会执行二者之中的一个。</li></ul><p><font color=#c7254e size=3>observer</font><br>观察者是可观察对象所发送数据的消费者，观察者简单而言是一组回调函数 ， 分别对应可观察对象发送的通知的类型:next, error和complete。<br>例：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> observer=&#123;  next:<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Observer got a next value: &#x27;</span> + x),  error: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Observer got an error: &#x27;</span> + err),  complete: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Observer got a complete notification&#x27;</span>)&#125;</code></pre><p>使用观察者，需要订阅可观察对象:</p><pre><code class="hljs JavaScript">observable.subscribe(observer)</code></pre><p>观察者是可选的，如果你不提供某个回调函数，可观察对象的执行仍然会照常发生，但某个类型的通知将不会发生，因为在观察者对象中没有对应于他们的回调函数。<br>下面代码中仅提供回调来作为参数也是可以的：</p><pre><code class="hljs JavaScript">observable.subscribe(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Observer got a next value: &#x27;</span> + x));</code></pre><p><font color=#c7254e size=3>Subscription</font><br>订阅表示一次性资源的对象，通常是一个可观察对象的执行。订阅对象有一个重要的方法:unsubscribe，该方法不需要参数，它可以弃掉可观察对象所持有的资源。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> observable = Rx.Observable.interval(<span class="hljs-number">1000</span>);<span class="hljs-keyword">var</span> subscription = observable.subscribe(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(x));<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;  subscription.unsubscribe();&#125;, <span class="hljs-number">3000</span>)</code></pre><p>//output: 1, 2<br>订阅对象也可以被放置在一起，因此对一个订阅对象的unsubscribe()进行调用，可以对多个订阅进行取消。做法是:把一个订阅”加”进另一个订阅。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> observable1 = Rx.Observable.interval(<span class="hljs-number">400</span>);<span class="hljs-keyword">var</span> observable2 = Rx.Observable.interval(<span class="hljs-number">300</span>);<span class="hljs-keyword">var</span> subscription = observable1.subscribe(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;first: &#x27;</span> + x));<span class="hljs-keyword">var</span> childSubscription = observable2.subscribe(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;second: &#x27;</span> + x));subscription.add(childSubscription);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  subscription.unsubscribe();&#125;, <span class="hljs-number">1000</span>);<span class="hljs-comment">//output:</span><span class="hljs-comment">//second: 0</span><span class="hljs-comment">//first: 0</span><span class="hljs-comment">//second: 1</span><span class="hljs-comment">//first: 1</span><span class="hljs-comment">//second: 2</span></code></pre><p>remove(otherSubscription)方法,用于解除被add添加的子订阅。</p><p><font color=#c7254e size=3>Subject</font><br>Subject是允许值被多播到多个观察者的一种特殊的Observable。它同时拥有 Observer 和 Observable 的行为, 而纯粹的可观察对象是单播的(每一个订阅的观察者拥有单独的可观察对象的执行)。<br>注意：<br>1.每一个Subject都是一个observable可观察对象，给定一个Subject后，你可以订阅它，提供的观察者将会正常的开始接收值。从观察者的角度来看，它不能判断一个可观察对象的执行时来自于单播的Observable还是来自于一个Subject.<br>2.每一个Subject都是一个Observer观察者对象。它是一个拥有next()/error()/complete()方法的对象。要想Subject提供一个新的值，只需调用next()，它将会被多播至用来监听Subject的观察者。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> subject = <span class="hljs-keyword">new</span> Rx.Subject();subject.subscribe(&#123;  next: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observerA: &#x27;</span> + v)&#125;);subject.subscribe(&#123;  next: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observerB: &#x27;</span> + v)&#125;);subject.next(<span class="hljs-number">1</span>);subject.next(<span class="hljs-number">2</span>);<span class="hljs-comment">//output:</span><span class="hljs-comment">//observerA: 1</span><span class="hljs-comment">//observerB: 1</span><span class="hljs-comment">//observerA: 2</span><span class="hljs-comment">//observerB: 2</span></code></pre><blockquote><p>注意：在订阅创建之前执行的 next() 就会丢失</p></blockquote><p>Subject也是一个观察者，你可以提供一个Subject当做observable.subscribe()的参数</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> subject = <span class="hljs-keyword">new</span> Rx.Subject();subject.subscribe(&#123;  next: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observerA: &#x27;</span> + v)&#125;);subject.subscribe(&#123;  next: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observerB: &#x27;</span> + v)&#125;);<span class="hljs-keyword">var</span> observable = Rx.Observable.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);observable.subscribe(subject);<span class="hljs-comment">//output:</span><span class="hljs-comment">//observerA: 1</span><span class="hljs-comment">//observerB: 1</span><span class="hljs-comment">//observerA: 2</span><span class="hljs-comment">//observerB: 2</span></code></pre><p>BehaviorSubject<br>BehaviorSubject中可以传递一个当前值。当新的观察者订阅它时，会立即接受到这个来自BehaviorSubject的”当前值”。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> subject = <span class="hljs-keyword">new</span> Rx.BehaviorSubject(<span class="hljs-number">0</span>);subject.subscribe(&#123;  next: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observerA: &#x27;</span> + v)&#125;);subject.next(<span class="hljs-number">1</span>);subject.next(<span class="hljs-number">2</span>);subject.subscribe(&#123;  next: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observerB: &#x27;</span> + v)&#125;);subject.next(<span class="hljs-number">3</span>)<span class="hljs-comment">//output:</span><span class="hljs-comment">//observerA: 0</span><span class="hljs-comment">//observerA: 1</span><span class="hljs-comment">//observerA: 2</span><span class="hljs-comment">//observerA: 3</span><span class="hljs-comment">//observerB: 3</span></code></pre><p>ReplaySubject<br>ReplaySubject可以把已经发出的值保存在缓存之中。<br>AsyncSubject<br>AsyncSubject只发送给观察者可观察对象执行的最新值，并且仅在执行结束时。即当触发complete时会返回最新值，触发error时会返回err的内容</p><p><font color=#c7254e size=3>Operators</font><br>操作符是可观察对象上定义的方法，例如.map(…),.filter(…),.merge(…)，等等。当他们被调用，会返回一个新的可观察对象，并不会改变当前的可观察对象实例。</p><p><font color=#c7254e size=3>Scheduler</font><br>调度者控制着何时启动一个订阅和何时通知被发送。它有三个组件构成：一个调度者是一个数据结构，它知道如何根据优先级或其他标准存储和排列任务。一个调度者是一个执行上下文。它表示何处何时任务被执行。一个调度者具有虚拟的时钟。它通过调度器上的getter方法now()提供了“时间”的概念。 在特定调度程序上调度的任务将仅仅遵守由该时钟表示的时间。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> observable = Rx.Observable.of(<span class="hljs-string">&#x27;foo&#x27;</span>, Rx.Scheduler.async)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before&#x27;</span>)observable.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value));<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;after&#x27;</span>)<span class="hljs-comment">//output:before, after, foo</span></code></pre><p>官网：<a href="http://reactivex.io/rxjs/manual/overview.html">http://reactivex.io/rxjs/manual/overview.html</a><br>rx操作符：<a href="http://rxmarbles.com/">http://rxmarbles.com</a></p>]]></content>
    
    
    <categories>
      
      <category>异步</category>
      
    </categories>
    
    
    <tags>
      
      <tag>callback</tag>
      
      <tag>promise</tag>
      
      <tag>async</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
